{"version":3,"sources":["../src/PrismaQueue.ts","../prisma/client/client.ts","../prisma/client/internal/class.ts","../prisma/client/internal/prismaNamespace.ts","../src/PrismaJob.ts","../src/utils/debug.ts","../src/utils/error.ts","../src/utils/prisma.ts","../src/utils/string.ts","../src/utils/stringify.ts","../src/utils/time.ts","../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { Cron } from \"croner\";\nimport { EventEmitter } from \"events\";\nimport assert from \"node:assert\";\nimport { Prisma, PrismaClient } from \"../prisma\";\nimport { PrismaJob } from \"./PrismaJob\";\nimport type { ClientOptions, DatabaseJob, JobCreator, JobPayload, JobResult, JobWorker } from \"./types\";\nimport {\n  AbortError,\n  calculateDelay,\n  debug,\n  escape,\n  getTableName,\n  serializeError,\n  uncapitalize,\n  waitFor,\n} from \"./utils\";\n\nexport type PrismaQueueOptions = {\n  client: ClientOptions;\n  name?: string;\n  maxAttempts?: number | null;\n  maxConcurrency?: number;\n  pollInterval?: number;\n  jobInterval?: number;\n  modelName?: string;\n  tableName?: string;\n  deleteOn?: \"success\" | \"failure\" | \"always\" | \"never\";\n  /**\n   * @deprecated This option is deprecated and will be removed in a future version.\n   * The queue now uses JavaScript Date objects instead of SQL NOW() to avoid timezone issues.\n   */\n  alignTimeZone?: boolean;\n};\n\nexport type EnqueueOptions = {\n  cron?: string;\n  runAt?: Date;\n  key?: string;\n  maxAttempts?: number;\n  priority?: number;\n};\n\nexport type ScheduleOptions = Omit<EnqueueOptions, \"key\" | \"cron\"> & {\n  key: string;\n  cron: string;\n};\n\nexport type PrismaQueueEvents<T extends JobPayload = JobPayload, U extends JobResult = JobResult> = {\n  enqueue: (job: PrismaJob<T, U>) => void;\n  dequeue: (job: PrismaJob<T, U>) => void;\n  success: (result: U, job: PrismaJob<T, U>) => void;\n  error: (error: unknown, job?: PrismaJob<T, U>) => void;\n};\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface PrismaQueue<T extends JobPayload = JobPayload, U extends JobResult = JobResult> {\n  on<E extends keyof PrismaQueueEvents<T, U>>(event: E, listener: PrismaQueueEvents<T, U>[E]): this;\n  once<E extends keyof PrismaQueueEvents<T, U>>(event: E, listener: PrismaQueueEvents<T, U>[E]): this;\n  emit<E extends keyof PrismaQueueEvents<T, U>>(\n    event: E,\n    ...args: Parameters<PrismaQueueEvents<T, U>[E]>\n  ): boolean;\n}\n\nconst DEFAULT_MAX_CONCURRENCY = 1;\nconst DEFAULT_POLL_INTERVAL = 10 * 1000;\nconst DEFAULT_JOB_INTERVAL = 50;\nconst DEFAULT_DELETE_ON = \"never\";\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class PrismaQueue<\n  T extends JobPayload = JobPayload,\n  U extends JobResult = JobResult,\n> extends EventEmitter {\n  public prisma: PrismaClient;\n  private name: string;\n  private config: Required<Omit<PrismaQueueOptions, \"name\" | \"client\">>;\n\n  private concurrency = 0;\n  private stopped = true;\n  private abortController = new AbortController();\n\n  /**\n   * Constructs a PrismaQueue object with specified options and a worker function.\n   * @param options - Configuration options for the queue.\n   * @param worker - The worker function that processes jobs.\n   */\n  public constructor(\n    private options: PrismaQueueOptions,\n    public worker: JobWorker<T, U>,\n  ) {\n    super();\n\n    this.prisma = new PrismaClient(this.options.client);\n\n    const {\n      name = \"default\",\n      modelName = \"QueueJob\",\n      tableName = getTableName(this.prisma, modelName),\n      maxAttempts = null,\n      maxConcurrency = DEFAULT_MAX_CONCURRENCY,\n      pollInterval = DEFAULT_POLL_INTERVAL,\n      jobInterval = DEFAULT_JOB_INTERVAL,\n      deleteOn = DEFAULT_DELETE_ON,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      alignTimeZone = false,\n    } = this.options;\n\n    assert(name.length <= 255, \"name must be less or equal to 255 chars\");\n    assert(pollInterval >= 100, \"pollInterval must be more than 100 ms\");\n    assert(jobInterval >= 10, \"jobInterval must be more than 10 ms\");\n\n    this.name = name;\n    this.config = {\n      modelName,\n      tableName,\n      maxAttempts,\n      maxConcurrency,\n      pollInterval,\n      jobInterval,\n      deleteOn,\n      alignTimeZone,\n    };\n\n    // Default error handler\n    this.on(\"error\", (error, job) => {\n      debug(\n        job\n          ? `Job with id=${job.id} failed for queue named=\"${this.name}\" with error`\n          : `Queue named=\"${this.name}\" encountered an unexpected error`,\n        error,\n      );\n    });\n\n    // Warn about deprecated alignTimeZone option\n    if (alignTimeZone) {\n      console.warn(\n        \"[prisma-queue] The alignTimeZone option is deprecated and will be removed in a future version. \" +\n          \"The queue now uses JavaScript Date objects instead of SQL NOW() to avoid timezone issues.\",\n      );\n    }\n  }\n\n  /**\n   * Gets the Prisma delegate associated with the queue job model.\n   */\n  private get model(): Prisma.QueueJobDelegate {\n    const queueJobKey = uncapitalize(this.config.modelName) as \"queueJob\";\n    return this.prisma[queueJobKey];\n  }\n\n  /**\n   * Starts the job processing in the queue.\n   */\n  public async start(): Promise<void> {\n    debug(`starting queue named=\"${this.name}\"...`);\n    if (!this.stopped) {\n      debug(`queue named=\"${this.name}\" is already running, skipping...`);\n      return;\n    }\n    this.stopped = false;\n    // Reset abort controller for new start\n    this.abortController = new AbortController();\n    return this.poll();\n  }\n\n  /**\n   * Stops the job processing in the queue.\n   * Waits for all in-flight jobs to complete before returning.\n   * @param options - Stop options\n   * @param options.timeout - Maximum time in milliseconds to wait for in-flight jobs (default: 30000)\n   */\n  public async stop(options: { timeout?: number } = {}): Promise<void> {\n    const { timeout = 30000 } = options;\n    debug(`stopping queue named=\"${this.name}\"...`);\n    this.stopped = true;\n    this.abortController.abort();\n\n    // Wait for all in-flight jobs to complete\n    const checkInterval = 100; // Check every 100ms\n    const startTime = Date.now();\n\n    while (this.concurrency > 0) {\n      if (Date.now() - startTime > timeout) {\n        debug(\n          `stop() timed out after ${timeout}ms waiting for ${this.concurrency} in-flight jobs to complete for queue named=\"${this.name}\"`,\n        );\n        break;\n      }\n      await waitFor(checkInterval);\n    }\n\n    debug(`queue named=\"${this.name}\" stopped with ${this.concurrency} remaining jobs`);\n  }\n\n  /**\n   * Adds a job to the queue.\n   * @param payloadOrFunction - The job payload or a function that returns a job payload.\n   * @param options - Options for the job, such as scheduling and attempts.\n   */\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  public add = this.enqueue;\n\n  /**\n   * Adds a job to the queue.\n   * @param payloadOrFunction - The job payload or a function that returns a job payload.\n   * @param options - Options for the job, such as scheduling and attempts.\n   */\n  public async enqueue(\n    payloadOrFunction: T | JobCreator<T>,\n    options: EnqueueOptions = {},\n  ): Promise<PrismaJob<T, U>> {\n    debug(`enqueue`, this.name, payloadOrFunction, options);\n    const { name: queueName, config } = this;\n    const { key = null, cron = null, maxAttempts = config.maxAttempts, priority = 0, runAt } = options;\n    const queueJobKey = uncapitalize(this.config.modelName) as \"queueJob\";\n    const now = new Date();\n    const record = await this.prisma.$transaction(async (client) => {\n      const model = client[queueJobKey];\n      const payload =\n        payloadOrFunction instanceof Function ? await payloadOrFunction(client) : payloadOrFunction;\n      const data = {\n        queue: queueName,\n        cron,\n        payload,\n        maxAttempts,\n        priority,\n        key,\n        createdAt: now,\n        runAt: runAt ?? now,\n      };\n      if (key && runAt) {\n        const { count } = await model.deleteMany({\n          where: {\n            queue: queueName,\n            key,\n            runAt: {\n              gte: now,\n              not: runAt,\n            },\n          },\n        });\n        if (count > 0) {\n          debug(`deleted ${count} conflicting upcoming queue jobs`);\n        }\n        return await model.upsert({\n          where: { key_runAt: { key, runAt } },\n          create: data,\n          update: data,\n        });\n      }\n      return await model.create({ data });\n    });\n    const job = new PrismaJob(record as DatabaseJob<T, U>, {\n      model: this.model,\n      client: this.prisma,\n    });\n    this.emit(\"enqueue\", job);\n    return job;\n  }\n\n  /**\n   * Schedules a job according to the cron expression or a specific run time.\n   * @param options - Scheduling options including cron, key, and run time.\n   * @param payloadOrFunction - The job payload or a function that returns a job payload.\n   */\n  public async schedule(\n    options: ScheduleOptions,\n    payloadOrFunction: T | JobCreator<T>,\n  ): Promise<PrismaJob<T, U>> {\n    debug(`schedule`, this.name, options, payloadOrFunction);\n    const { key, cron, runAt: firstRunAt, ...otherOptions } = options;\n    const runAt = firstRunAt ?? new Cron(cron).nextRun();\n    assert(runAt, `Failed to find a future occurence for given cron`);\n    return this.enqueue(payloadOrFunction, { key, cron, runAt, ...otherOptions });\n  }\n\n  /**\n   * Polls the queue and processes jobs according to the configured intervals and concurrency settings.\n   */\n  private async poll(): Promise<void> {\n    const { maxConcurrency, pollInterval, jobInterval } = this.config;\n    debug(\n      `polling queue named=\"${this.name}\" with pollInterval=${pollInterval} maxConcurrency=${maxConcurrency}...`,\n    );\n\n    try {\n      while (!this.stopped) {\n        // Wait for the queue to be ready\n        if (this.concurrency >= maxConcurrency) {\n          await waitFor(pollInterval, this.abortController.signal);\n          continue;\n        }\n        // Query the queue size only when needed to reduce database load.\n        const queueSize = await this.size(true);\n        if (queueSize === 0) {\n          await waitFor(pollInterval, this.abortController.signal);\n          continue;\n        }\n\n        // Process available jobs up to concurrency limit\n        const slotsAvailable = maxConcurrency - this.concurrency;\n        const jobsToProcess = Math.min(queueSize, slotsAvailable);\n\n        for (let i = 0; i < jobsToProcess && !this.stopped; i++) {\n          debug(`processing job from queue named=\"${this.name}\"...`);\n          this.concurrency++;\n          setImmediate(() => {\n            this.dequeue()\n              .then((job) => {\n                if (job) {\n                  debug(`dequeued job({id: ${job.id}, payload: ${JSON.stringify(job.payload)}})`);\n                }\n              })\n              .catch((error: unknown) => {\n                this.emit(\"error\", error);\n              })\n              .finally(() => {\n                this.concurrency--;\n              });\n          });\n          await waitFor(jobInterval, this.abortController.signal);\n        }\n\n        // Wait before checking queue again\n        await waitFor(jobInterval * 2, this.abortController.signal);\n      }\n    } catch (error) {\n      if (error instanceof AbortError) {\n        debug(`polling for queue named=\"${this.name}\" was aborted`);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Dequeues and processes the next job in the queue. Handles locking and error management internally.\n   * @returns {Promise<PrismaJob<T, U> | null>} The job that was processed or null if no job was available.\n   */\n  private async dequeue(): Promise<PrismaJob<T, U> | null> {\n    if (this.stopped) {\n      return null;\n    }\n    debug(`dequeuing from queue named=\"${this.name}\"...`);\n    const { name: queueName } = this;\n    const { tableName: tableNameRaw, deleteOn } = this.config;\n    const tableName = escape(tableNameRaw);\n    const queueJobKey = uncapitalize(this.config.modelName) as \"queueJob\";\n    const now = new Date();\n    const job = await this.prisma.$transaction(\n      async (client) => {\n        const rows = await client.$queryRawUnsafe<DatabaseJob<T, U>[]>(\n          `UPDATE ${tableName} SET \"processedAt\" = $2, \"attempts\" = \"attempts\" + 1\n           WHERE id = (\n             SELECT id\n             FROM ${tableName}\n             WHERE (${tableName}.\"queue\" = $1)\n               AND (${tableName}.\"finishedAt\" IS NULL)\n               AND (${tableName}.\"runAt\" <= $2)\n               AND (${tableName}.\"notBefore\" IS NULL OR ${tableName}.\"notBefore\" <= $2)\n             ORDER BY ${tableName}.\"priority\" ASC, ${tableName}.\"runAt\" ASC\n             FOR UPDATE SKIP LOCKED\n             LIMIT 1\n           )\n           RETURNING *;`,\n          queueName,\n          now,\n        );\n        if (!rows.length || !rows[0]) {\n          debug(`no jobs found in queue named=\"${this.name}\"`);\n          // @NOTE Failed to acquire a lock\n          return null;\n        }\n        const { id, payload, attempts, maxAttempts } = rows[0];\n        const job = new PrismaJob<T, U>(rows[0], {\n          model: client[queueJobKey],\n          client,\n        });\n        let result;\n        try {\n          debug(`starting worker for job({id: ${id}, payload: ${JSON.stringify(payload)}})`);\n          result = await this.worker(job, this.prisma);\n          debug(`finished worker for job({id: ${id}, payload: ${JSON.stringify(payload)}})`);\n          const date = new Date();\n          await job.update({ finishedAt: date, progress: 100, result, error: Prisma.DbNull });\n          this.emit(\"success\", result, job);\n          if (deleteOn === \"success\" || deleteOn === \"always\") {\n            await job.delete();\n          }\n        } catch (error) {\n          const date = new Date();\n          debug(\n            `failed finishing job({id: ${id}, payload: ${JSON.stringify(payload)}}) with error=\"${String(error)}\"`,\n          );\n          const isFinished = maxAttempts && attempts >= maxAttempts;\n          const notBefore = new Date(date.getTime() + calculateDelay(attempts));\n          if (!isFinished) {\n            debug(`will retry at notBefore=${notBefore.toISOString()} (attempts=${attempts})`);\n          }\n          await job.update({\n            finishedAt: isFinished ? date : null,\n            failedAt: date,\n            error: serializeError(error),\n            notBefore: isFinished ? null : notBefore,\n          });\n          this.emit(\"error\", error, job);\n          if (deleteOn === \"failure\" || deleteOn === \"always\") {\n            await job.delete();\n          }\n        }\n        return job;\n      },\n      // @NOTE https://github.com/prisma/prisma/issues/11565#issuecomment-1031380271\n      { timeout: 864e5 },\n    );\n    if (job) {\n      this.emit(\"dequeue\", job);\n      const { key, cron, payload, finishedAt } = job;\n      if (finishedAt && cron && key) {\n        // Schedule next cron\n        debug(\n          `scheduling next cron job({key: ${key}, cron: ${cron}}) with payload=${JSON.stringify(payload)}`,\n        );\n        await this.schedule({ key, cron }, payload);\n      }\n    }\n\n    return job;\n  }\n\n  /**\n   * Counts the number of jobs in the queue, optionally only those available for processing.\n   * @param {boolean} onlyAvailable - If true, counts only jobs that are ready to be processed.\n   * @returns {Promise<number>} The number of jobs.\n   */\n  public async size(onlyAvailable?: boolean): Promise<number> {\n    const { name: queueName } = this;\n    const date = new Date();\n    const where: Prisma.QueueJobWhereInput = { queue: queueName, finishedAt: null };\n    if (onlyAvailable) {\n      where.runAt = { lte: date };\n      where.AND = { OR: [{ notBefore: { lte: date } }, { notBefore: null }] };\n    }\n    return await this.model.count({\n      where,\n    });\n  }\n}\n","\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nglobalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more QueueJobs\n * const queueJobs = await prisma.queueJob.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model QueueJob\n * \n */\nexport type QueueJob = Prisma.QueueJobModel\n","\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.2.0\",\n  \"engineVersion\": \"0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\",\n  \"activeProvider\": \"postgresql\",\n  \"inlineSchema\": \"// This is your Prisma schema file,\\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\\n\\ngenerator client {\\n  provider        = \\\"prisma-client\\\"\\n  output          = \\\"./client\\\"\\n  previewFeatures = []\\n}\\n\\ndatasource db {\\n  provider = \\\"postgresql\\\"\\n}\\n\\nmodel QueueJob {\\n  id          BigInt    @id @default(autoincrement()) @db.BigInt\\n  queue       String\\n  key         String?\\n  cron        String?\\n  payload     Json?\\n  result      Json?\\n  error       Json?\\n  progress    Int       @default(0)\\n  priority    Int       @default(0)\\n  attempts    Int       @default(0)\\n  maxAttempts Int?\\n  runAt       DateTime  @default(now())\\n  notBefore   DateTime?\\n  finishedAt  DateTime?\\n  processedAt DateTime?\\n  failedAt    DateTime?\\n  createdAt   DateTime  @default(now())\\n  updatedAt   DateTime  @updatedAt\\n\\n  @@unique([key, runAt])\\n  @@index([queue, priority, runAt, finishedAt])\\n  @@map(\\\"queue_jobs\\\")\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"QueueJob\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"BigInt\\\"},{\\\"name\\\":\\\"queue\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"key\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"cron\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"payload\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"result\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"error\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Json\\\"},{\\\"name\\\":\\\"progress\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"priority\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"attempts\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"maxAttempts\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"runAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"notBefore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"finishedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"processedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"failedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":\\\"queue_jobs\\\"}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_bg.postgresql.mjs\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_bg.postgresql.wasm-base64.mjs\")\n    return await decodeBase64AsWasm(wasm)\n  }\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more QueueJobs\n   * const queueJobs = await prisma.queueJob.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://pris.ly/d/client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more QueueJobs\n * const queueJobs = await prisma.queueJob.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.queueJob`: Exposes CRUD operations for the **QueueJob** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more QueueJobs\n    * const queueJobs = await prisma.queueJob.findMany()\n    * ```\n    */\n  get queueJob(): Prisma.QueueJobDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n","\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.2.0\n * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.2.0\",\n  engine: \"0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  QueueJob: 'QueueJob'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"queueJob\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    QueueJob: {\n      payload: Prisma.$QueueJobPayload<ExtArgs>\n      fields: Prisma.QueueJobFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.QueueJobFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.QueueJobFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>\n        }\n        findFirst: {\n          args: Prisma.QueueJobFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.QueueJobFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>\n        }\n        findMany: {\n          args: Prisma.QueueJobFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>[]\n        }\n        create: {\n          args: Prisma.QueueJobCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>\n        }\n        createMany: {\n          args: Prisma.QueueJobCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.QueueJobCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>[]\n        }\n        delete: {\n          args: Prisma.QueueJobDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>\n        }\n        update: {\n          args: Prisma.QueueJobUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>\n        }\n        deleteMany: {\n          args: Prisma.QueueJobDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.QueueJobUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.QueueJobUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>[]\n        }\n        upsert: {\n          args: Prisma.QueueJobUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$QueueJobPayload>\n        }\n        aggregate: {\n          args: Prisma.QueueJobAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateQueueJob>\n        }\n        groupBy: {\n          args: Prisma.QueueJobGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.QueueJobGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.QueueJobCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.QueueJobCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  ReadUncommitted: 'ReadUncommitted',\n  ReadCommitted: 'ReadCommitted',\n  RepeatableRead: 'RepeatableRead',\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const QueueJobScalarFieldEnum = {\n  id: 'id',\n  queue: 'queue',\n  key: 'key',\n  cron: 'cron',\n  payload: 'payload',\n  result: 'result',\n  error: 'error',\n  progress: 'progress',\n  priority: 'priority',\n  attempts: 'attempts',\n  maxAttempts: 'maxAttempts',\n  runAt: 'runAt',\n  notBefore: 'notBefore',\n  finishedAt: 'finishedAt',\n  processedAt: 'processedAt',\n  failedAt: 'failedAt',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type QueueJobScalarFieldEnum = (typeof QueueJobScalarFieldEnum)[keyof typeof QueueJobScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const NullableJsonNullValueInput = {\n  DbNull: DbNull,\n  JsonNull: JsonNull\n} as const\n\nexport type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]\n\n\nexport const QueryMode = {\n  default: 'default',\n  insensitive: 'insensitive'\n} as const\n\nexport type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\nexport const JsonNullValueFilter = {\n  DbNull: DbNull,\n  JsonNull: JsonNull,\n  AnyNull: AnyNull\n} as const\n\nexport type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'BigInt'\n */\nexport type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>\n    \n\n\n/**\n * Reference to a field of type 'BigInt[]'\n */\nexport type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>\n    \n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'String[]'\n */\nexport type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n/**\n * Reference to a field of type 'Json'\n */\nexport type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>\n    \n\n\n/**\n * Reference to a field of type 'QueryMode'\n */\nexport type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>\n    \n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n/**\n * Reference to a field of type 'Int[]'\n */\nexport type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime[]'\n */\nexport type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'Float[]'\n */\nexport type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://pris.ly/d/logging).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n  /**\n   * SQL commenter plugins that add metadata to SQL queries as comments.\n   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   adapter,\n   *   comments: [\n   *     traceContext(),\n   *     queryInsights(),\n   *   ],\n   * })\n   * ```\n   */\n  comments?: runtime.SqlCommenterPlugin[]\n}\nexport type GlobalOmitConfig = {\n  queueJob?: Prisma.QueueJobOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n","import { Prisma } from \"../prisma\";\nimport type { DatabaseJob, ITXClient } from \"./types\";\n// import { debug } from \"./utils\";\n\nexport type PrismaJobOptions = {\n  model: Prisma.QueueJobDelegate;\n  client: ITXClient;\n};\n\n/**\n * Represents a job within a Prisma-managed queue.\n */\nexport class PrismaJob<Payload, Result> {\n  #model: Prisma.QueueJobDelegate;\n  #client: ITXClient;\n  #record: DatabaseJob<Payload, Result>;\n\n  public readonly id;\n  public readonly createdAt: Date = new Date();\n\n  /**\n   * Constructs a new PrismaJob instance with the provided job record and database access objects.\n   * @param record - The initial database job record.\n   * @param model - The Prisma delegate used for database operations related to the job.\n   * @param client - The Prisma client for executing arbitrary queries.\n   */\n  constructor(record: DatabaseJob<Payload, Result>, { model, client }: PrismaJobOptions) {\n    this.#model = model;\n    this.#client = client;\n    this.#record = record;\n    this.id = record.id;\n  }\n\n  /**\n   * Internal method to assign a new record to the job.\n   * @param record - Optional new record to assign.\n   */\n  #assign(record?: DatabaseJob<Payload, Result>) {\n    if (record) {\n      this.#record = record;\n    }\n  }\n\n  /**\n   * Gets the current job record.\n   */\n  public get record(): DatabaseJob<Payload, Result> {\n    return this.#record;\n  }\n\n  /**\n   * Gets the job's unique key if any.\n   */\n  public get key() {\n    return this.#record.key;\n  }\n\n  /**\n   * Gets the job's queue name.\n   */\n  public get queue() {\n    return this.#record.queue;\n  }\n\n  /**\n   * Gets the CRON expression associated with the job for recurring scheduling.\n   */\n  public get cron() {\n    return this.#record.cron;\n  }\n\n  /**\n   * Gets the job's priority level.\n   */\n  public get priority() {\n    return this.#record.priority;\n  }\n\n  /**\n   * Gets the payload associated with the job.\n   */\n  public get payload() {\n    return this.#record.payload;\n  }\n\n  /**\n   * Gets the timestamp when the job was finished.\n   */\n  public get finishedAt() {\n    return this.#record.finishedAt;\n  }\n\n  /**\n   * Gets the error record if the job failed.\n   */\n  public get error() {\n    return this.#record.error;\n  }\n\n  /**\n   * Updates the job's progress percentage.\n   * @param progress - The new progress percentage.\n   */\n  public async progress(progress: number): Promise<DatabaseJob<Payload, Result>> {\n    return await this.update({ progress: Math.max(0, Math.min(100, progress)) });\n  }\n\n  /**\n   * Fetches the latest job record from the database and updates the internal state.\n   */\n  public async fetch(): Promise<DatabaseJob<Payload, Result>> {\n    const record = (await this.#model.findUnique({\n      where: { id: this.id },\n    })) as DatabaseJob<Payload, Result>;\n    this.#assign(record);\n    return record;\n  }\n\n  /**\n   * Updates the job record in the database with new data.\n   * @param data - The new data to be merged with the existing job record.\n   */\n  public async update(data: Prisma.QueueJobUpdateInput): Promise<DatabaseJob<Payload, Result>> {\n    const record = (await this.#model.update({\n      where: { id: this.id },\n      data,\n    })) as DatabaseJob<Payload, Result>;\n    this.#assign(record);\n    return record;\n  }\n\n  /**\n   * Deletes the job from the database.\n   */\n  public async delete(): Promise<DatabaseJob<Payload, Result>> {\n    const record = (await this.#model.delete({\n      where: { id: this.id },\n    })) as DatabaseJob<Payload, Result>;\n    return record;\n  }\n\n  /**\n   * Checks if the job is currently locked by another transaction.\n   * @returns {Promise<boolean>} True if the job is locked, false otherwise.\n   */\n  public async isLocked(): Promise<boolean> {\n    try {\n      // Attempt to select and lock the row with a timeout\n      await this.#client.$executeRawUnsafe(\n        `SELECT \"id\" FROM \"public\".\"queue_jobs\" WHERE \"id\" = $1 FOR UPDATE NOWAIT`,\n        this.id,\n      );\n\n      // If we reach here, the row is not locked\n      return false;\n    } catch (error) {\n      // Handle specific error types that indicate lock contention\n      if (error instanceof Prisma.PrismaClientKnownRequestError) {\n        // PostgreSQL's lock_not_available\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return (error.meta as any)?.driverAdapterError?.cause?.code === \"55P03\";\n      }\n      // Re-throw other unexpected errors\n      throw error;\n    }\n  }\n}\n","import createDebug from \"debug\";\n\nexport const debug = createDebug(\"prisma-queue\");\n","export const serializeError = (err: unknown) => {\n  if (err instanceof Error) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack,\n    };\n  }\n  return {\n    name: \"UnknownError\",\n    message: String(err),\n    stack: undefined,\n  };\n};\n","import { defineDmmfProperty } from \"@prisma/client/runtime/client.js\";\nimport { ITXClient } from \"../types\";\n\ntype RuntimeDataModel = Parameters<typeof defineDmmfProperty>[1];\n\n/**\n * Converts a PascalCase model name to snake_case table name.\n * @example \"QueueJob\" -> \"queue_job\"\n */\nconst toSnakeCase = (str: string): string => {\n  return str.replace(/([a-z])([A-Z])/g, \"$1_$2\").toLowerCase();\n};\n\n/**\n * Gets the database table name for a Prisma model.\n * Falls back to snake_case conversion if DMMF is not available (e.g., edge environments).\n */\nexport const getTableName = (prisma: ITXClient, modelName: string): string => {\n  try {\n    // @ts-expect-error from messing with prisma internals\n    const datamodel = prisma._runtimeDataModel as RuntimeDataModel;\n    const model = datamodel.models[\"QueueJob\"];\n    if (model?.dbName) {\n      return model.dbName;\n    }\n  } catch {\n    // DMMF not available (edge environment or separately generated Prisma client)\n  }\n  // Fallback to conventional snake_case table name\n  return toSnakeCase(modelName);\n};\n","export const escape = (name: string) => '\"' + name.replace(/\"/g, '\"\"') + '\"';\n\nexport const capitalize = (string: string) => string.charAt(0).toUpperCase() + string.slice(1);\nexport const uncapitalize = (string: string) => string.charAt(0).toLowerCase() + string.slice(1);\n","/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport type { Prisma } from \"../../prisma\";\n\ntype InputJsonValue = Prisma.InputJsonValue;\ntype InputJsonObject = Prisma.InputJsonObject;\n\nexport function prepareForJson<T>(originalValue: T): InputJsonValue {\n  if (typeof originalValue === \"undefined\") {\n    return {\n      $type: \"undefined\",\n    };\n  } else if (typeof originalValue === \"bigint\") {\n    return {\n      $type: \"bigint\",\n      $value: `0x${originalValue.toString(16)}`,\n    };\n  } else if (originalValue instanceof Map) {\n    return {\n      $type: \"Map\",\n      $value: Array.from(originalValue.entries()),\n    };\n  } else if (originalValue instanceof Set) {\n    return {\n      $type: \"Set\",\n      $value: Array.from(originalValue.values()),\n    };\n  } else if (originalValue instanceof Date) {\n    return {\n      $type: \"Date\",\n      $value: originalValue.getTime(),\n    };\n  } else if (typeof originalValue === \"object\" && originalValue !== null) {\n    if (Array.isArray(originalValue)) {\n      return originalValue.map(prepareForJson);\n    } else {\n      const copy: Record<string, InputJsonValue> = {};\n      for (const key in originalValue) {\n        copy[key] = prepareForJson(originalValue[key]);\n      }\n      return copy;\n    }\n  }\n  return originalValue as InputJsonValue;\n}\n\nexport function restoreFromJson<T = unknown>(preparedValue: InputJsonValue): T {\n  if (typeof preparedValue === \"object\" && preparedValue !== null && \"$type\" in preparedValue) {\n    if (preparedValue[\"$type\"] === \"undefined\") {\n      return undefined as T;\n    } else if (preparedValue[\"$type\"] === \"bigint\") {\n      return BigInt(preparedValue[\"$value\"] as string) as T;\n    } else if (preparedValue[\"$type\"] === \"Map\") {\n      return new Map(preparedValue[\"$value\"] as [unknown, unknown][]) as T;\n    } else if (preparedValue[\"$type\"] === \"Set\") {\n      return new Set(preparedValue[\"$value\"] as unknown[]) as T;\n    } else if (preparedValue[\"$type\"] === \"Date\") {\n      return new Date(preparedValue[\"$value\"] as number) as T;\n    }\n  } else if (typeof preparedValue === \"object\" && preparedValue !== null) {\n    if (Array.isArray(preparedValue)) {\n      return preparedValue.map(restoreFromJson) as T;\n    } else {\n      const copy: Record<string, unknown> = {};\n      for (const [key, value] of Object.entries(preparedValue)) {\n        copy[key] = restoreFromJson(value as InputJsonObject);\n      }\n      return copy as T;\n    }\n  }\n  return preparedValue as T;\n}\n","export class AbortError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n\nexport const waitFor = async (ms: number, signal?: AbortSignal): Promise<void> =>\n  new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      resolve();\n    }, ms);\n\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        clearTimeout(timeout);\n        reject(new AbortError(\"Aborted\"));\n      });\n    }\n  });\n\nexport const calculateDelay = (attempts: number): number =>\n  Math.min(1000 * Math.pow(2, Math.max(1, attempts)) + Math.random() * 100, Math.pow(2, 31) - 1);\n\nexport const getCurrentTimeZone = (): string => Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n/**\n * Validates that a timezone string is safe to use in SQL.\n * PostgreSQL timezone names should only contain alphanumeric characters, underscores, slashes, plus, and minus.\n * @param timezone - The timezone string to validate\n * @returns true if the timezone is safe\n */\nexport const isValidTimeZone = (timezone: string): boolean => {\n  // Allow only safe characters: alphanumeric, underscore, slash, plus, minus, and colon\n  // This matches valid IANA timezone names like \"America/New_York\", \"UTC\", \"GMT+8\", etc.\n  return /^[a-zA-Z0-9_/+:-]+$/.test(timezone) && timezone.length > 0 && timezone.length < 100;\n};\n","import { PrismaQueue, type PrismaQueueOptions } from \"./PrismaQueue\";\nimport type { JobPayload, JobResult, JobWorker } from \"./types\";\n\nexport * from \"./PrismaJob\";\nexport * from \"./PrismaQueue\";\nexport type * from \"./types\";\n\nexport { prepareForJson, restoreFromJson } from \"./utils\";\n\n/**\n * Factory function to create a new PrismaQueue instance.\n * This function simplifies the instantiation of a PrismaQueue by wrapping it into a function call.\n *\n * @param options - The configuration options for the PrismaQueue. These options configure how the queue interacts with the database and controls job processing behavior.\n * @param worker - The worker function that will process each job. The worker function is called with each dequeued job and is responsible for executing the job's logic.\n *\n * @returns An instance of PrismaQueue configured with the provided options and worker.\n *\n * @template T - The type of the job payload. It extends JobPayload which can be further extended to include more specific data types as needed.\n * @template U - The type of the result expected from the worker function after processing a job. It extends JobResult which can be specialized based on the application's needs.\n *\n * @example\n * // Create a new queue for email sending jobs\n * const emailQueue = createQueue<EmailPayload, void>({\n *   name: 'emails',\n *   prisma: new PrismaClient(),\n *   pollInterval: 5000,\n * }, async (job) => {\n *   await sendEmail(job.payload);\n * });\n */\nexport const createQueue = <T extends JobPayload = JobPayload, U extends JobResult = JobResult>(\n  options: PrismaQueueOptions,\n  worker: JobWorker<T, U>,\n) => {\n  return new PrismaQueue<T, U>(options, worker);\n};\n"],"mappings":"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","names":["Buffer","AnyNull","DbNull","Decimal","JsonNull","NullTypes","PrismaClientInitializationError","PrismaClientKnownRequestError","PrismaClientRustPanicError","PrismaClientUnknownRequestError","PrismaClientValidationError","Sql","empty","join","raw","runtime","config","job"]}